/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
// void free(void *ptr);
// int puts(const char *s);
// ssize_t write(int fd, const void *buf, size_t n);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int printf(const char *format, ...);
// void *memset(void *s, int c, size_t n);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int memcmp(const void *s1, const void *s2, size_t n);
// __int64 _gmon_start__(void); weak
// void *memcpy(void *dest, const void *src, size_t n);
// void *malloc(size_t size);
// int open(const char *file, int oflag, ...);
// void __noreturn exit(int status);
// __int64 __fastcall _cxa_finalize(_QWORD); weak
__int64 (**sub_9D0())(void);
__int64 (**sub_A60())(void);
__int64 sub_AA0();
__int64 __fastcall main(__int64 a1, char **a2, char **a3);
void __fastcall __noreturn error(__int64 a1);
unsigned __int64 __fastcall init_map(const void *code, size_t a2); // idb
__int64 __fastcall bot_16(char a1);
char __fastcall top_16(unsigned __int8 a1);
__int64 __fastcall get_text8(struc_1 *a1, unsigned int a2); // idb
__int64 __fastcall get_text16(struc_1 *a1, unsigned int a2); // idb
__int64 __fastcall get_text32(struc_1 *a1, unsigned int a2); // idb
unsigned __int64 __fastcall set_text8(struc_1 *a1, unsigned int a2, char a3); // idb
unsigned __int64 __fastcall set_text32(struc_1 *a1, unsigned int a2, int a3); // idb
__int64 __fastcall get_stack8(struc_1 *a1, unsigned int stack_ptr, unsigned int off); // idb
__int64 __fastcall sub_FC4(__int64 a1, unsigned int a2, unsigned int a3);
__int64 __fastcall get_stack32(struc_1 *a1, __int64 stack_ptr, unsigned int off);
unsigned __int64 __fastcall set_stack8(struc_1 *a1, __int64 stack_ptr, unsigned int offset, char a4);
unsigned __int64 __fastcall set_stack32(struc_1 *a1, __int64 stack_ptr, unsigned int off, int value); // idb
void exec_vm();
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3);
void term_proc();
// void free(void *ptr);
// void *malloc(size_t size);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 Jv_RegisterClasses(void); weak

//-------------------------------------------------------------------------
// Data declarations

void *__ptr32 off_36C0[256] =
{
  (void *__ptr32 )0xFFFFFDF7LL,
  (void *__ptr32 )0xFFFFE47BLL,
  (void *__ptr32 )0xFFFFDB0FLL,
  (void *__ptr32 )0xFFFFE6F1LL,
  (void *__ptr32 )0xFFFFE332LL,
  (void *__ptr32 )0xFFFFE93ELL,
  (void *__ptr32 )0xFFFFE8E4LL,
  (void *__ptr32 )0xFFFFE1EDLL,
  (void *__ptr32 )0xFFFFF91BLL,
  (void *__ptr32 )0xFFFFDF21LL,
  (void *__ptr32 )0xFFFFE291LL,
  (void *__ptr32 )0xFFFFF7F9LL,
  (void *__ptr32 )0xFFFFDE70LL,
  (void *__ptr32 )0xFFFFF067LL,
  (void *__ptr32 )0xFFFFF1C8LL,
  (void *__ptr32 )0xFFFFEF05LL,
  (void *__ptr32 )0xFFFFE566LL,
  (void *__ptr32 )0xFFFFEB6DLL,
  (void *__ptr32 )0xFFFFDC54LL,
  (void *__ptr32 )0xFFFFEDA6LL,
  (void *__ptr32 )0xFFFFE7B8LL,
  (void *__ptr32 )0xFFFFF5ECLL,
  (void *__ptr32 )0xFFFFE4FELL,
  (void *__ptr32 )0xFFFFE3D7LL,
  (void *__ptr32 )0xFFFFE883LL,
  (void *__ptr32 )0xFFFFFA68LL,
  (void *__ptr32 )0xFFFFE13CLL,
  (void *__ptr32 )0xFFFFE9C3LL,
  (void *__ptr32 )0xFFFFF48ALL,
  (void *__ptr32 )0xFFFFDFD6LL,
  (void *__ptr32 )0xFFFFDDB7LL,
  (void *__ptr32 )0xFFFFFB94LL,
  (void *__ptr32 )0xFFFFF327LL,
  (void *__ptr32 )0xFFFFDBA3LL,
  (void *__ptr32 )0xFFFFE08BLL,
  (void *__ptr32 )0xFFFFE62ALL,
  (void *__ptr32 )0xFFFFEA48LL,
  (void *__ptr32 )0xFFFFE917LL,
  (void *__ptr32 )0xFFFFDD05LL,
  (void *__ptr32 )0xFFFFEC8BLL,
  (void *__ptr32 )0xFFFFF6B6LL,
  (void *__ptr32 )0xFFFFFBB6LL,
  (void *__ptr32 )0xFFFFFC34LL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFE0BLL,
  (void *__ptr32 )0xFFFFFD15LL
}; // weak
__int64 (__fastcall *off_204D70[2])() = { &sub_AA0, &sub_A60 }; // weak
__int64 (__fastcall *off_204D78)() = &sub_A60; // weak
_UNKNOWN unk_204D80; // weak
void *off_205008 = &off_205008; // weak
_UNKNOWN code; // weak
char prompt[176] =
{
  '1',
  '.',
  ' ',
  'p',
  'u',
  's',
  'h',
  ' ',
  'e',
  'l',
  'e',
  'm',
  'e',
  'n',
  't',
  '\n',
  '2',
  '.',
  ' ',
  's',
  'h',
  'o',
  'w',
  ' ',
  'e',
  'l',
  'e',
  'm',
  'e',
  'n',
  't',
  's',
  '\n',
  '3',
  '.',
  ' ',
  'p',
  'o',
  'p',
  ' ',
  'e',
  'l',
  'e',
  'm',
  'e',
  'n',
  't',
  '\n',
  '4',
  '.',
  ' ',
  'e',
  'x',
  'i',
  't',
  '\n',
  '>',
  '>',
  '>',
  ' ',
  'p',
  'l',
  'e',
  'a',
  's',
  'e',
  ' ',
  'i',
  'n',
  'p',
  'u',
  't',
  ' ',
  't',
  'h',
  'e',
  ' ',
  'c',
  'o',
  'n',
  't',
  'e',
  'n',
  't',
  ':',
  ' ',
  'p',
  'u',
  's',
  'h',
  ' ',
  'e',
  'l',
  'e',
  'm',
  'e',
  'n',
  't',
  ' ',
  's',
  'u',
  'c',
  'c',
  'e',
  'e',
  'd',
  '!',
  '\n',
  'p',
  'o',
  'p',
  ' ',
  'e',
  'l',
  'e',
  'm',
  'e',
  'n',
  't',
  ' ',
  's',
  'u',
  'c',
  'c',
  'e',
  'e',
  'd',
  '!',
  '\n',
  'c',
  'a',
  'n',
  'n',
  'o',
  't',
  ' ',
  'p',
  'o',
  'p',
  ' ',
  'a',
  'n',
  ' ',
  'e',
  'm',
  'p',
  't',
  'y',
  ' ',
  's',
  't',
  'a',
  'c',
  'k',
  '!',
  '\n',
  '\n',
  'P',
  'l',
  'e',
  'a',
  's',
  'e',
  ' ',
  'i',
  'n',
  'p',
  'u',
  't',
  ' ',
  'y',
  'o',
  'u',
  'r',
  ' ',
  'n'
};
_UNKNOWN unk_205258; // weak
_UNKNOWN unk_20525F; // weak
char byte_205260; // weak
char prog_segment[4096];
int regs[]; // weak
__int64 ret_ptr; // weak
unsigned __int64 stack_ptr;
__int64 pc_ptr; // weak
array *heap[256];
struc_1 mem;
// extern _UNKNOWN __cxa_finalize; weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00000000000008D8) ----------------------------------------------------
void *init_proc()
{
  void *result; // rax

  result = &__gmon_start__;
  if ( &__gmon_start__ )
    result = (void *)_gmon_start__();
  return result;
}
// 968: using guessed type __int64 _gmon_start__(void);

//----- (00000000000009A0) ----------------------------------------------------
#error "9A6: positive sp value has been found (funcsize=3)"

//----- (00000000000009D0) ----------------------------------------------------
__int64 (**sub_9D0())(void)
{
  __int64 (**result)(void); // rax

  result = (__int64 (**)(void))(&unk_20525F - &unk_205258);
  if ( (unsigned __int64)(&unk_20525F - &unk_205258) > 0xE )
  {
    result = &ITM_deregisterTMCloneTable;
    if ( &ITM_deregisterTMCloneTable )
      result = (__int64 (**)(void))ITM_deregisterTMCloneTable();
  }
  return result;
}
// 206B80: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (0000000000000A60) ----------------------------------------------------
__int64 (**sub_A60())(void)
{
  __int64 (**result)(void); // rax

  if ( !byte_205260 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_205008);
    result = sub_9D0();
    byte_205260 = 1;
  }
  return result;
}
// 990: using guessed type __int64 __fastcall _cxa_finalize(_QWORD);
// 205008: using guessed type void *off_205008;
// 205260: using guessed type char byte_205260;

//----- (0000000000000AA0) ----------------------------------------------------
__int64 sub_AA0()
{
  if ( unk_204D80 && &Jv_RegisterClasses )
    Jv_RegisterClasses();
  return 0LL;
}
// 206B90: using guessed type __int64 Jv_RegisterClasses(void);

//----- (0000000000000AD0) ----------------------------------------------------
__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  qmemcpy(prog_segment, &code, 0x17DuLL);
  *(_QWORD *)&prog_segment[0x800] = *(_QWORD *)prompt;
  *(_QWORD *)&prog_segment[0x8AE] = *(_QWORD *)&prompt[174];
  qmemcpy(
    (void *)((unsigned __int64)&prog_segment[2056] & 0xFFFFFFFFFFFFFFF8LL),
    (const void *)(prompt - &prog_segment[-((unsigned __int64)&prog_segment[2056] & 0xFFFFFFFFFFFFFFF8LL) + 2048]),
    8LL
  * ((((unsigned int)&prog_segment[-((unsigned __int64)&prog_segment[2056] & 0xFFFFFFFFFFFFFFF8LL) + 2048] + 182) & 0xFFFFFFF8) >> 3));
  init_map(prog_segment, 0x1000uLL);
  exec_vm();
  return 0LL;
}

//----- (0000000000000BB8) ----------------------------------------------------
void __fastcall __noreturn error(__int64 a1)
{
  printf("VM fault: %s\n", a1);
  exit(-1);
}

//----- (0000000000000BF5) ----------------------------------------------------
unsigned __int64 __fastcall init_map(const void *code, size_t a2)
{
  signed int i; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  mem.text = (__int64)mmap(0LL, 0x6000uLL, 3, 34, -1, 0LL);
  mem.stack = mmap(0LL, 0x2000uLL, 3, 34, -1, 0LL);
  mem.retstack = (__int64)mmap(0LL, 0x1000uLL, 3, 34, -1, 0LL);
  memcpy((void *)(mem.text + 0x4000), code, a2);
  for ( i = 0; i <= 15; ++i )
    regs[i] = 0;
  ret_ptr = 0x1000LL;
  stack_ptr = 0x2000LL;
  pc_ptr = 0x4000LL;
  return __readfsqword(0x28u) ^ v4;
}
// 206280: using guessed type int regs[];
// 2062C0: using guessed type __int64 ret_ptr;
// 2062D0: using guessed type __int64 pc_ptr;

//----- (0000000000000D1F) ----------------------------------------------------
__int64 __fastcall bot_16(char a1)
{
  return a1 & 0xF;
}

//----- (0000000000000D58) ----------------------------------------------------
char __fastcall top_16(unsigned __int8 a1)
{
  return a1 >> 4;
}

//----- (0000000000000D91) ----------------------------------------------------
__int64 __fastcall get_text8(struc_1 *a1, unsigned int a2)
{
  if ( a2 > 0x5FFF )
    error((__int64)"Invalid address");
  return *(unsigned __int8 *)(a1->text + a2);
}

//----- (0000000000000DEB) ----------------------------------------------------
__int64 __fastcall get_text16(struc_1 *a1, unsigned int a2)
{
  if ( a2 > 0x5FFE )
    error((__int64)"Invalid address");
  return *(unsigned __int16 *)(a1->text + a2);
}

//----- (0000000000000E45) ----------------------------------------------------
__int64 __fastcall get_text32(struc_1 *a1, unsigned int a2)
{
  if ( a2 > 0x5FFC )
    error((__int64)"Invalid address");
  return *(unsigned int *)(a1->text + a2);
}

//----- (0000000000000E9E) ----------------------------------------------------
unsigned __int64 __fastcall set_text8(struc_1 *a1, unsigned int a2, char a3)
{
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  if ( a2 > 0x5FFF )
    error((__int64)"Invalid address");
  *(_BYTE *)(a2 + a1->text) = a3;
  return __readfsqword(0x28u) ^ v4;
}

//----- (0000000000000F01) ----------------------------------------------------
unsigned __int64 __fastcall set_text32(struc_1 *a1, unsigned int a2, int a3)
{
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  if ( a2 > 0x5FFC )
    error((__int64)"Invalid address");
  *(_DWORD *)(a2 + a1->text) = a3;
  return __readfsqword(0x28u) ^ v4;
}

//----- (0000000000000F61) ----------------------------------------------------
__int64 __fastcall get_stack8(struc_1 *a1, unsigned int stack_ptr, unsigned int off)
{
  if ( off > 0xFF )
    error((__int64)"Invalid offset");
  return *((unsigned __int8 *)a1->stack + stack_ptr + (unsigned __int64)off);
}

//----- (0000000000000FC4) ----------------------------------------------------
__int64 __fastcall sub_FC4(__int64 a1, unsigned int a2, unsigned int a3)
{
  if ( a3 > 0xFE )
    error((__int64)"Invalid offset");
  return *(unsigned __int16 *)(a2 + (unsigned __int64)a3 + *(_QWORD *)(a1 + 8));
}

//----- (0000000000001027) ----------------------------------------------------
__int64 __fastcall get_stack32(struc_1 *a1, __int64 stack_ptr, unsigned int off)
{
  if ( off > 0xFC )
    error((__int64)"Invalid offset");
  return *(unsigned int *)((char *)a1->stack + off + stack_ptr);
}

//----- (000000000000108B) ----------------------------------------------------
unsigned __int64 __fastcall set_stack8(struc_1 *a1, __int64 stack_ptr, unsigned int offset, char a4)
{
  unsigned __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  if ( offset > 0xFF )
    error((__int64)"Invalid offset");
  *((_BYTE *)a1->stack + offset + stack_ptr) = a4;
  return __readfsqword(0x28u) ^ v5;
}

//----- (00000000000010F9) ----------------------------------------------------
unsigned __int64 __fastcall set_stack32(struc_1 *a1, __int64 stack_ptr, unsigned int off, int value)
{
  unsigned __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  if ( off > 0xFC )
    error((__int64)"Invalid offset");
  *(_DWORD *)((char *)a1->stack + off + stack_ptr) = value;
  return __readfsqword(0x28u) ^ v5;
}

//----- (0000000000001164) ----------------------------------------------------
void exec_vm()
{
  char v0; // ST0C_1
  unsigned __int8 v1; // ST0D_1
  char v2; // ST0F_1
  unsigned __int8 v3; // ST10_1
  unsigned __int8 v4; // ST11_1
  char v5; // ST12_1
  unsigned __int8 top_7; // ST13_1
  unsigned __int8 bot_7; // ST14_1
  char v8; // ST15_1
  unsigned __int8 v9; // ST16_1
  unsigned __int8 v10; // ST17_1
  char v11; // ST18_1
  unsigned __int8 v12; // ST19_1
  unsigned __int8 v13; // ST1A_1
  char v14; // ST1B_1
  unsigned __int8 top_4; // ST1C_1
  unsigned __int8 bot_4; // ST1D_1
  char v17; // ST1E_1
  unsigned __int8 top_1; // ST1F_1
  unsigned __int8 bot_1; // ST20_1
  char v20; // ST21_1
  unsigned __int8 v21; // ST22_1
  unsigned __int8 v22; // ST23_1
  char v23; // ST24_1
  unsigned __int8 v24; // ST25_1
  unsigned __int8 v25; // ST26_1
  char v26; // ST27_1
  unsigned __int8 v27; // ST28_1
  unsigned __int8 v28; // ST29_1
  char v29; // ST2A_1
  unsigned __int8 v30; // ST2B_1
  __int64 v31; // rbx
  char v32; // ST2D_1
  unsigned __int8 top_2; // ST2E_1
  unsigned __int8 bot_2; // ST2F_1
  char v35; // ST30_1
  unsigned __int8 v36; // ST31_1
  __int64 v37; // rbx
  char v38; // ST33_1
  unsigned __int8 top_10; // ST34_1
  unsigned __int8 bot_9; // ST35_1
  unsigned __int8 v41; // ST36_1
  char v42; // ST38_1
  unsigned __int8 top_6; // ST39_1
  unsigned __int8 bot_6; // ST3A_1
  char v45; // ST3B_1
  unsigned __int8 top_12; // ST3C_1
  __int64 bot_12; // rbx
  char v48; // ST3E_1
  unsigned __int8 v49; // ST3F_1
  unsigned __int8 v50; // ST40_1
  char v51; // ST41_1
  unsigned __int8 top_9; // ST42_1
  __int64 bot_8; // rbx
  unsigned __int16 v54; // ST64_2
  unsigned __int8 v55; // al
  unsigned __int8 v56; // al
  unsigned __int8 v57; // al
  unsigned __int8 v58; // al
  unsigned __int8 v59; // al
  char v60; // ST49_1
  unsigned __int8 v61; // al
  char v62; // ST4B_1
  unsigned __int8 v63; // al
  char v64; // ST4D_1
  unsigned __int8 v65; // al
  char v66; // ST4F_1
  unsigned __int8 v67; // al
  char v68; // ST51_1
  unsigned __int8 v69; // al
  char v70; // ST53_1
  unsigned __int8 v71; // al
  unsigned __int8 v72; // al
  char v73; // ST55_1
  char v74; // ST58_1
  char v75; // ST5B_1
  char v76; // ST5E_1
  unsigned __int8 v77; // al
  char v78; // al
  unsigned __int8 bot_10; // ST61_1
  char v80; // ST62_1
  int fd; // STAC_4
  unsigned __int8 top_8; // [rsp+4Ah] [rbp-F6h]
  unsigned __int8 top_5; // [rsp+4Ch] [rbp-F4h]
  unsigned __int8 top1; // [rsp+4Eh] [rbp-F2h]
  unsigned __int8 bot_5; // [rsp+50h] [rbp-F0h]
  unsigned __int8 v86; // [rsp+52h] [rbp-EEh]
  unsigned __int8 v87; // [rsp+54h] [rbp-ECh]
  unsigned __int8 bot_11; // [rsp+56h] [rbp-EAh]
  unsigned __int8 top_11; // [rsp+57h] [rbp-E9h]
  unsigned __int8 bot_3; // [rsp+59h] [rbp-E7h]
  unsigned __int8 top_3; // [rsp+5Ah] [rbp-E6h]
  unsigned __int8 bot; // [rsp+5Ch] [rbp-E4h]
  unsigned __int8 top; // [rsp+5Dh] [rbp-E3h]
  unsigned __int8 v94; // [rsp+5Fh] [rbp-E1h]
  unsigned __int8 v95; // [rsp+60h] [rbp-E0h]
  unsigned __int8 v96; // [rsp+63h] [rbp-DDh]
  unsigned __int16 v97; // [rsp+66h] [rbp-DAh]
  unsigned __int16 r_top; // [rsp+68h] [rbp-D8h]
  unsigned __int16 r_top_3; // [rsp+6Ah] [rbp-D6h]
  unsigned __int16 r_top2_3; // [rsp+6Ch] [rbp-D4h]
  unsigned __int16 r_top2_2; // [rsp+6Eh] [rbp-D2h]
  unsigned __int16 r_top2; // [rsp+70h] [rbp-D0h]
  unsigned __int16 r_top2_1; // [rsp+72h] [rbp-CEh]
  unsigned __int16 v104; // [rsp+74h] [rbp-CCh]
  unsigned __int16 v105; // [rsp+76h] [rbp-CAh]
  unsigned int i; // [rsp+78h] [rbp-C8h]
  unsigned int ind; // [rsp+7Ch] [rbp-C4h]
  unsigned int j; // [rsp+80h] [rbp-C0h]
  unsigned int k; // [rsp+84h] [rbp-BCh]
  unsigned int r_bot_2; // [rsp+88h] [rbp-B8h]
  unsigned int r_bot_1; // [rsp+8Ch] [rbp-B4h]
  unsigned int r_bot; // [rsp+90h] [rbp-B0h]
  unsigned int r_top_1; // [rsp+94h] [rbp-ACh]
  unsigned int v114; // [rsp+98h] [rbp-A8h]
  unsigned int v115; // [rsp+9Ch] [rbp-A4h]
  unsigned int r_top_2; // [rsp+A0h] [rbp-A0h]
  unsigned int v117; // [rsp+A8h] [rbp-98h]
  array *v118; // [rsp+B8h] [rbp-88h]
  array *heap; // [rsp+C0h] [rbp-80h]
  array *v120; // [rsp+C8h] [rbp-78h]
  ssize_t v121; // [rsp+D0h] [rbp-70h]
  ssize_t res; // [rsp+D8h] [rbp-68h]
  char s1[32]; // [rsp+E0h] [rbp-60h]
  char buf; // [rsp+100h] [rbp-40h]
  unsigned __int64 v125; // [rsp+128h] [rbp-18h]

  v125 = __readfsqword(0x28u);
  while ( 1 )                                   // switch pc_ptr
  {
    get_text8(&mem, pc_ptr);
    switch ( (unsigned int)off_36C0 )
    {
      case 0u:                                  // nop
        ++pc_ptr;
        break;
      case 1u:                                  // sp -= imm
        v41 = get_text8(&mem, (signed int)pc_ptr + 1);
        stack_ptr -= v41;
        memset((char *)mem.stack + stack_ptr, 0, v41);
        pc_ptr += 2LL;
        break;
      case 2u:                                  // reg[bot] = reg[top]
        v0 = get_text8(&mem, (signed int)pc_ptr + 1);
        v1 = top_16(v0);
        regs[(unsigned __int8)bot_16(v0)] = regs[v1];
        pc_ptr += 2LL;
        break;
      case 3u:                                  // stack[sp + r[bot]] = r[top]
        if ( stack_ptr == 0x2000 )
          error((__int64)"Trying to access a empty stack");
        v48 = get_text8(&mem, (signed int)pc_ptr + 1);
        v49 = top_16(v48);
        v50 = bot_16(v48);
        set_stack8(&mem, stack_ptr, regs[v50], regs[v49]);
        pc_ptr += 2LL;
        break;
      case 4u:                                  // r[bot] = byte text[r[top]]
        v35 = get_text8(&mem, (signed int)pc_ptr + 1);
        v36 = top_16(v35);
        v37 = (unsigned __int8)bot_16(v35);
        regs[(signed int)v37] = (unsigned __int8)get_text8(&mem, regs[v36]);
        pc_ptr += 2LL;
        break;
      case 5u:                                  // bz reg[top], pc
        v55 = get_text8(&mem, (signed int)pc_ptr + 1);
        if ( regs[(unsigned __int8)top_16(v55)] )
          pc_ptr += 4LL;
        else
          pc_ptr = (unsigned __int16)get_text16(&mem, (signed int)pc_ptr + 2);
        break;
      case 6u:                                  // ret
        pc_ptr = *(unsigned int *)(mem.retstack + ret_ptr);
        ret_ptr += 4LL;
        break;
      case 7u:                                  // r[bot] = dword text[r[top]]
        v29 = get_text8(&mem, (signed int)pc_ptr + 1);
        v30 = top_16(v29);
        v31 = (unsigned __int8)bot_16(v29);
        regs[(signed int)v31] = get_text32(&mem, regs[v30]);
        pc_ptr += 2LL;
        break;
      case 8u:                                  // read(0, sp + regs[bot], regs[top])
        v75 = get_text8(&mem, (signed int)pc_ptr + 1);
        bot = bot_16(v75);
        top = top_16(v75);
        if ( (unsigned int)regs[top] > 0x100 || regs[bot] > (unsigned int)(0x100 - regs[top]) )
          error((__int64)"Invalid read syscall arguments");
        res = read(0, (char *)mem.stack + stack_ptr + (unsigned int)regs[bot], (unsigned int)regs[top]);
        if ( res <= 0 )
          error((__int64)"Error in read");
        regs[0] = res;
        pc_ptr += 2LL;
        break;
      case 9u:                                  // shr reg[bot], reg[top]
        v17 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_1 = top_16(v17);
        bot_1 = bot_16(v17);
        regs[bot_1] = (unsigned int)regs[bot_1] >> regs[top_1];
        pc_ptr += 2LL;
        break;
      case 0xAu:                                // text[reg[bot]] = reg[top]
        v32 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_2 = top_16(v32);
        bot_2 = bot_16(v32);
        set_text32(&mem, regs[bot_2], regs[top_2]);
        pc_ptr += 2LL;
        break;
      case 0xBu:                                // write(1, text[reg[bot]], reg[top])
        v74 = get_text8(&mem, (signed int)pc_ptr + 1);
        bot_3 = bot_16(v74);
        top_3 = top_16(v74);
        if ( (unsigned int)regs[top_3] > 0x6000 || regs[bot_3] > (unsigned int)(0x6000 - regs[top_3]) )
          error((__int64)"Invalid read syscall arguments");
        write(1, (const void *)(mem.text + (unsigned int)regs[bot_3]), (unsigned int)regs[top_3]);
        pc_ptr += 2LL;
        break;
      case 0xCu:                                // xor r[bot], r[top]
        v14 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_4 = top_16(v14);
        bot_4 = bot_16(v14);
        regs[bot_4] ^= regs[top_4];
        pc_ptr += 2LL;
        break;
      case 0xDu:                                // arrs[r[bot]][r[top2]] = r[top1]
        v64 = get_text8(&mem, (signed int)pc_ptr + 1);
        top1 = top_16(v64);
        r_bot = regs[(unsigned __int8)bot_16(v64)];
        v65 = get_text8(&mem, (signed int)pc_ptr + 2);
        r_top2 = regs[(unsigned __int8)top_16(v65)];
        if ( r_bot > 0xFF || !::heap[r_bot] )
          error((__int64)"Trying to access a non-exist array");
        if ( (unsigned int)r_top2 >= ::heap[r_bot]->size )
          error((__int64)"Array index out of bound");
        ::heap[r_bot]->arr[r_top2] = regs[top1];
        pc_ptr += 3LL;
        break;
      case 0xEu:                                // r[bot] = ((int*)arrs[r[top1]])[r[top2]]
        v66 = get_text8(&mem, (signed int)pc_ptr + 1);
        r_top_1 = regs[(unsigned __int8)top_16(v66)];
        bot_5 = bot_16(v66);
        v67 = get_text8(&mem, (signed int)pc_ptr + 2);
        r_top2_1 = regs[(unsigned __int8)top_16(v67)];
        if ( r_top_1 > 0xFF || !::heap[r_top_1] )
          error((__int64)"Trying to access a non-exist array");
        if ( (unsigned int)r_top2_1 >= ::heap[r_top_1]->size )// BUG: accessing int elements, not bytes
          error((__int64)"Array index out of bound");
        regs[bot_5] = *(_DWORD *)&::heap[r_top_1]->arr[4 * r_top2_1];
        pc_ptr += 3LL;
        break;
      case 0xFu:                                // warrs[r_bot][r_top2] = reg[r_top]
        v62 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_5 = top_16(v62);
        r_bot_1 = regs[(unsigned __int8)bot_16(v62)];
        v63 = get_text8(&mem, (signed int)pc_ptr + 2);
        r_top2_2 = regs[(unsigned __int8)top_16(v63)];
        if ( r_bot_1 > 0xFF || !::heap[r_bot_1] )
          error((__int64)"Trying to access a non-exist array");
        if ( (unsigned int)r_top2_2 >= ::heap[r_bot_1]->size )
          error((__int64)"Array index out of bound");
        *(_WORD *)&::heap[r_bot_1]->arr[2 * r_top2_2] = regs[top_5];
        pc_ptr += 3LL;
        break;
      case 0x10u:                               // mov dword [sp + r_bot], r_top
        if ( stack_ptr == 0x2000 )
          error((__int64)"Trying to access a empty stack");
        v42 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_6 = top_16(v42);
        bot_6 = bot_16(v42);
        set_stack32(&mem, stack_ptr, regs[bot_6], regs[top_6]);
        pc_ptr += 2LL;
        break;
      case 0x11u:                               // alloc r_top
        v58 = get_text8(&mem, (signed int)pc_ptr + 1);
        r_top = regs[(unsigned __int8)top_16(v58)];
        heap = (array *)malloc(2 * (r_top + 2LL));
        for ( ind = 1; ind <= 0xFF && ::heap[ind]; ++ind )
          ;
        if ( ind == 256 )
          error((__int64)"Heap is full");
        ::heap[ind] = heap;
        ::heap[ind]->size = r_top;
        regs[0] = ind;
        pc_ptr += 2LL;
        break;
      case 0x12u:                               // sub r_bot, r_top
        v5 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_7 = top_16(v5);
        bot_7 = bot_16(v5);
        regs[bot_7] -= regs[top_7];
        pc_ptr += 2LL;
        break;
      case 0x13u:                               // iarr[r_bot][r_top2] = r[top]
        v60 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_8 = top_16(v60);
        r_bot_2 = regs[(unsigned __int8)bot_16(v60)];
        v61 = get_text8(&mem, (signed int)pc_ptr + 2);
        r_top2_3 = regs[(unsigned __int8)top_16(v61)];
        if ( r_bot_2 > 0xFF || !::heap[r_bot_2] )
          error((__int64)"Trying to access a non-exist array");
        if ( (unsigned int)r_top2_3 >= ::heap[r_bot_2]->size )
          error((__int64)"Array index out of bound");
        *(_DWORD *)&::heap[r_bot_2]->arr[4 * r_top2_3] = regs[top_8];
        pc_ptr += 3LL;
        break;
      case 0x14u:                               // mov r_bot, stack[sp + r_top]
        if ( stack_ptr == 0x2000 )
          error((__int64)"Trying to access a empty stack");
        v51 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_9 = top_16(v51);
        bot_8 = (unsigned __int8)bot_16(v51);
        regs[(signed int)bot_8] = (unsigned __int8)get_stack8(&mem, stack_ptr, regs[top_9]);
        pc_ptr += 2LL;
        break;
      case 0x15u:                               // free r_top
        v72 = get_text8(&mem, (signed int)pc_ptr + 1);
        r_top_2 = regs[(unsigned __int8)top_16(v72)];
        if ( r_top_2 > 0xFF || !::heap[r_top_2] )
          error((__int64)"Trying to access a non-exist array");
        free(::heap[r_top_2]);
        ::heap[r_top_2] = 0LL;
        pc_ptr += 2LL;
        break;
      case 0x16u:                               // add sp, imm
        stack_ptr += (unsigned __int8)get_text8(&mem, (signed int)pc_ptr + 1);
        if ( stack_ptr > 0x2000 )
          error((__int64)"Trying to free the stack too much");
        pc_ptr += 2LL;
        break;
      case 0x17u:                               // mov byte [r_bot], r_top
        v38 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_10 = top_16(v38);
        bot_9 = bot_16(v38);
        set_text8(&mem, regs[bot_9], regs[top_10]);
        pc_ptr += 2LL;
        break;
      case 0x18u:                               // call imm
        v54 = get_text16(&mem, (signed int)pc_ptr + 1);
        ret_ptr -= 4LL;
        *(_DWORD *)(mem.retstack + ret_ptr) = pc_ptr + 3;
        pc_ptr = v54;
        break;
      case 0x19u:                               // syswrite [sp + r{bot(b)}], len=r{top(b)}
        v76 = get_text8(&mem, (signed int)pc_ptr + 1);
        v94 = bot_16(v76);
        v95 = top_16(v76);
        if ( (unsigned int)regs[v95] > 0x100 || regs[v94] > (unsigned int)(256 - regs[v95]) )
          error((__int64)"Invalid read syscall arguments");
        write(1, (char *)mem.stack + stack_ptr + (unsigned int)regs[v94], (unsigned int)regs[v95]);
        pc_ptr += 2LL;
        break;
      case 0x1Au:                               // and r_bot, r_top
        v26 = get_text8(&mem, (signed int)pc_ptr + 1);
        v27 = top_16(v26);
        v28 = bot_16(v26);
        regs[v28] &= regs[v27];
        pc_ptr += 2LL;
        break;
      case 0x1Bu:                               // bnz reg[top], pc
        v56 = get_text8(&mem, (signed int)pc_ptr + 1);
        if ( regs[(unsigned __int8)top_16(v56)] )
          pc_ptr = (unsigned __int16)get_text16(&mem, (signed int)pc_ptr + 2);
        else
          pc_ptr += 4LL;
        break;
      case 0x1Cu:
        v70 = get_text8(&mem, (signed int)pc_ptr + 1);
        v115 = regs[(unsigned __int8)top_16(v70)];
        v87 = bot_16(v70);
        v71 = get_text8(&mem, (signed int)pc_ptr + 2);
        v105 = regs[(unsigned __int8)top_16(v71)];
        if ( v115 > 0xFF || !::heap[v115] )
          error((__int64)"Trying to access a non-exist array");
        if ( (unsigned int)v105 >= ::heap[v115]->size )
          error((__int64)"Array index out of bound");
        regs[v87] = (unsigned __int8)::heap[v115]->arr[v105];
        pc_ptr += 3LL;
        break;
      case 0x1Du:                               // shl r_bot, r_top
        v20 = get_text8(&mem, (signed int)pc_ptr + 1);
        v21 = top_16(v20);
        v22 = bot_16(v20);
        regs[v22] <<= regs[v21];
        pc_ptr += 2LL;
        break;
      case 0x1Eu:                               // div r_bot, r_top
        v11 = get_text8(&mem, (signed int)pc_ptr + 1);
        v12 = top_16(v11);
        v13 = bot_16(v11);
        regs[v13] /= (unsigned int)regs[v12];
        pc_ptr += 2LL;
        break;
      case 0x1Fu:                               // exit(imm)
        v77 = get_text8(&mem, (signed int)pc_ptr + 1);
        exit(v77);
        return;
      case 0x20u:                               // get arr word
        v68 = get_text8(&mem, (signed int)pc_ptr + 1);
        v114 = regs[(unsigned __int8)top_16(v68)];
        v86 = bot_16(v68);
        v69 = get_text8(&mem, (signed int)pc_ptr + 2);
        v104 = regs[(unsigned __int8)top_16(v69)];
        if ( v114 > 0xFF || !::heap[v114] )
          error((__int64)"Trying to access a non-exist array");
        if ( (unsigned int)v104 >= ::heap[v114]->size )
          error((__int64)"Array index out of bound");
        regs[v86] = *(unsigned __int16 *)&::heap[v114]->arr[2 * v104];
        pc_ptr += 3LL;
        break;
      case 0x21u:                               // r_bot += r_top
        v2 = get_text8(&mem, (signed int)pc_ptr + 1);
        v3 = top_16(v2);
        v4 = bot_16(v2);
        regs[v4] += regs[v3];
        pc_ptr += 2LL;
        break;
      case 0x22u:                               // r_bot |= r_top
        v23 = get_text8(&mem, (signed int)pc_ptr + 1);
        v24 = top_16(v23);
        v25 = bot_16(v23);
        regs[v25] |= regs[v24];
        pc_ptr += 2LL;
        break;
      case 0x23u:                               // mov r_bot, dword stack[sp + r_top]
        if ( stack_ptr == 0x2000 )
          error((__int64)"Trying to access a empty stack");
        v45 = get_text8(&mem, (signed int)pc_ptr + 1);
        top_12 = top_16(v45);
        bot_12 = (unsigned __int8)bot_16(v45);
        regs[(signed int)bot_12] = get_stack32(&mem, stack_ptr, regs[top_12]);
        pc_ptr += 2LL;
        break;
      case 0x24u:                               // alloc_dword r_top
        v57 = get_text8(&mem, (signed int)pc_ptr + 1);
        v97 = regs[(unsigned __int8)top_16(v57)];
        v118 = (array *)malloc(4 * (v97 + 1LL));
        for ( i = 1; i <= 0xFF && ::heap[i]; ++i )
          ;
        if ( i == 256 )
          error((__int64)"Heap is full");
        ::heap[i] = v118;
        ::heap[i]->size = v97;
        regs[0] = i;
        pc_ptr += 2LL;
        break;
      case 0x25u:                               // jmp imm
        pc_ptr = (unsigned __int16)get_text16(&mem, (signed int)pc_ptr + 1);
        break;
      case 0x26u:                               // mul r_bot, r_top
        v8 = get_text8(&mem, (signed int)pc_ptr + 1);
        v9 = top_16(v8);
        v10 = bot_16(v8);
        regs[v10] *= regs[v9];
        pc_ptr += 2LL;
        break;
      case 0x27u:                               // alloc_byte r_top
        v59 = get_text8(&mem, (signed int)pc_ptr + 1);
        r_top_3 = regs[(unsigned __int8)top_16(v59)];
        v120 = (array *)malloc(r_top_3 + 4LL);
        for ( j = 1; j <= 0xFF && ::heap[j]; ++j )
          ;
        if ( j == 256 )
          error((__int64)"Heap is full");
        ::heap[j] = v120;
        ::heap[j]->size = r_top_3;
        regs[0] = j;
        pc_ptr += 2LL;
        break;
      case 0x28u:                               // read(0, text[r_bot], r_top)
        v73 = get_text8(&mem, (signed int)pc_ptr + 1);
        bot_11 = bot_16(v73);
        top_11 = top_16(v73);
        if ( (unsigned int)regs[top_11] > 0x6000 || regs[bot_11] > (unsigned int)(0x6000 - regs[top_11]) )
          error((__int64)"Invalid read syscall arguments");
        v121 = read(0, (void *)(mem.text + (unsigned int)regs[bot_11]), (unsigned int)regs[top_11]);
        if ( v121 <= 0 )
          error((__int64)"Error in read");
        regs[0] = v121;
        pc_ptr += 2LL;
        break;
      case 0x29u:                               // mov r_bot, imm
        v78 = get_text8(&mem, (signed int)pc_ptr + 1);
        bot_10 = bot_16(v78);
        regs[bot_10] = get_text32(&mem, (signed int)pc_ptr + 2);
        pc_ptr += 6LL;
        break;
      case 0x2Au:                               // mov r_bot, sizeof(arr[r_top])
        v80 = get_text8(&mem, (signed int)pc_ptr + 1);
        v117 = regs[(unsigned __int8)top_16(v80)];
        v96 = bot_16(v80);
        if ( v117 > 0xFF || !::heap[v117] )
          error((__int64)"Trying to access a non-exist array");
        regs[v96] = ::heap[v117]->size;
        pc_ptr += 2LL;
        break;
      case 0xFFu:
        memset(&buf, 0, 0x20uLL);
        for ( k = 0; k <= 0x13; ++k )
          s1[k] = get_text8(&mem, (unsigned int)pc_ptr + k + 1);
        if ( !memcmp(s1, "PleaseGiveMeTheFlag", 0x14uLL) )
        {
          fd = open("_flag", 0);
          read(fd, &buf, 0x1FuLL);
          close(fd);
          puts(&buf);
          exit(0);
        }
        error((__int64)"You must use the correct magic to open the sesame!");
        return;
      default:
        error((__int64)"Invalid Instruction");
        return;
    }
  }
}
// 36C0: using guessed type void *__ptr32 off_36C0[256];
// 206280: using guessed type int regs[];
// 2062C0: using guessed type __int64 ret_ptr;
// 2062D0: using guessed type __int64 pc_ptr;
// 1164: using guessed type char s1[32];

//----- (00000000000034E0) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r13
  signed __int64 v4; // rbp
  __int64 v5; // rbx

  v3 = a3;
  v4 = &off_204D78 - off_204D70;
  init_proc();
  if ( v4 )
  {
    v5 = 0LL;
    do
      ((void (__fastcall *)(_QWORD, __int64, __int64))off_204D70[v5++])(a1, a2, v3);
    while ( v5 != v4 );
  }
}
// 204D70: using guessed type __int64 (__fastcall *off_204D70[2])();
// 204D78: using guessed type __int64 (__fastcall *off_204D78)();

//----- (0000000000003554) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 23 function(s)"
