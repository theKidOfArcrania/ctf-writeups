/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn sys_exit();
__int64 __fastcall sys_putchar(char *);
__int64 __fastcall sys_read_input(__int64 a1, __int64 a2);
__int64 __fastcall sys_write(char *a1);
// __int64 __usercall sys_ls@<rax>(__int64 result@<rax>, unsigned __int16 a2@<dx>);
__int64 __fastcall sys_write_file(__int64 a1);
void __fastcall init_heap(chk *mem, __int64 size); // idb
void __fastcall heap_split(chk *p, __int64 a2); // idb
signed __int64 __fastcall malloc(unsigned __int64 request); // idb
void __cdecl coalese();
void __fastcall free(mem_data *a1);
__int64 __fastcall memset(_BYTE *a1, char a2, unsigned int a3);
void __fastcall memcpy(_BYTE *dst, char *src, __int64 a3);
__int64 __fastcall strlen(char *a1);
__int64 __fastcall memcmp(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall strcmp(_BYTE *a1, unsigned __int8 *a2);
__int64 __fastcall strncmp(char *a1, char *a2, __int64 a3);
__int64 __fastcall put_str(char *a1);
int __fastcall is_upper(char a1);
int __fastcall is_lower(signed int a1);
__int64 __fastcall to_lower(signed int a1);
_BYTE *__fastcall stristr(char *haystack, char *needle);
__int64 __fastcall prompt(__int64 a1);
__int64 __fastcall do_command(char *line, int a2); // idb
int __cdecl start();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_19; // weak
__int64 tail; // weak
chk *head;
__int64 size; // weak
env_name keys[16];
_UNKNOWN unk_3650; // weak
mem_data *values[310]; // idb


//----- (0000000000000011) ----------------------------------------------------
void __noreturn sys_exit()
{
  __asm { int     80h; LINUX - }
  __halt();
  JUMPOUT(loc_19);
}

//----- (0000000000000055) ----------------------------------------------------
__int64 __fastcall sys_putchar(char *a1)
{
  unsigned __int16 v1; // dx
  __int64 result; // rax

  result = (__int64)a1;
  __outbyte(v1, (unsigned __int8)a1);
  return result;
}

//----- (0000000000000069) ----------------------------------------------------
__int64 __fastcall sys_read_input(__int64 a1, __int64 a2)
{
  unsigned __int16 v2; // dx
  __int64 result; // rax

  result = a1;
  __outbyte(v2, a1);
  return result;
}

//----- (0000000000000076) ----------------------------------------------------
__int64 __fastcall sys_write(char *a1)
{
  unsigned __int16 v1; // dx
  __int64 result; // rax

  result = (__int64)a1;
  __outbyte(v1, (unsigned __int8)a1);
  return result;
}

//----- (0000000000000080) ----------------------------------------------------
__int64 __usercall sys_ls@<rax>(__int64 result@<rax>, unsigned __int16 a2@<dx>)
{
  __outbyte(a2, result);
  return result;
}

//----- (0000000000000087) ----------------------------------------------------
__int64 __fastcall sys_write_file(__int64 a1)
{
  unsigned __int16 v1; // dx
  __int64 result; // rax

  result = a1;
  __outbyte(v1, a1);
  return result;
}

//----- (00000000000000A0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall init_heap(chk *mem, __int64 size)
{
  tail = (__int64)mem;
  head = mem;
  head->size = size - 24;
  head->free = 1;
  head->next = 0LL;
  ::size = size;
}
// B0: write access to const memory at 1630 has been detected
// BB: write access to const memory at 1638 has been detected
// F5: write access to const memory at 1640 has been detected
// 1630: using guessed type __int64 tail;
// 1640: using guessed type __int64 size;

//----- (0000000000000100) ----------------------------------------------------
void __fastcall heap_split(chk *p, __int64 a2)
{
  chk *next; // ST00_8

  next = (chk *)((char *)p + a2 + 24);
  next->size = p->size - a2 - 24;
  next->free = 1;
  next->next = p->next;
  p->size = a2;
  p->free = 0;
  p->next = next;
}

//----- (0000000000000180) ----------------------------------------------------
signed __int64 __fastcall malloc(unsigned __int64 request)
{
  _BOOL1 do_break; // [rsp+7h] [rbp-29h]
  chk *p; // [rsp+18h] [rbp-18h]
  signed __int64 v4; // [rsp+28h] [rbp-8h]

  if ( !head->size )
    BUG();
  for ( p = head; ; p = p->next )
  {
    if ( p->size < request || (do_break = 0, !p->free) )
      do_break = p->next != 0LL;
    if ( !do_break )
      break;
  }
  if ( p->size == request )
  {
    p->free = 0;
    v4 = (signed __int64)p->data.str;
  }
  else if ( p->size <= request + 24 )
  {
    v4 = 0LL;
  }
  else
  {
    heap_split(p, request);
    v4 = (signed __int64)p->data.str;
  }
  return v4;
}

//----- (00000000000002B0) ----------------------------------------------------
void __cdecl coalese()
{
  chk *i; // [rsp+8h] [rbp-8h]

  for ( i = head; i->next; i = i->next )
  {
    if ( i->free )
    {
      if ( i->next->free )
      {
        i->size += i->next->size + offsetof(chk, data);
        i->next = i->next->next;
      }
    }
  }
}
// 2E4: user specified stroff has not been processed: chk offset 8

//----- (0000000000000340) ----------------------------------------------------
void __fastcall free(mem_data *a1)
{
  if ( tail <= (unsigned __int64)a1 && (unsigned __int64)a1 <= size + tail )
  {
    CONTAINING_RECORD(a1, chk, data)->free = 1;
    coalese();
  }
}
// 1630: using guessed type __int64 tail;
// 1640: using guessed type __int64 size;

//----- (00000000000003B0) ----------------------------------------------------
__int64 __fastcall memset(_BYTE *a1, char a2, unsigned int a3)
{
  __int64 result; // rax
  char *v4; // rdx
  char *v5; // [rsp+0h] [rbp-18h]
  unsigned int v6; // [rsp+8h] [rbp-10h]

  v6 = a3;
  v5 = a1;
  while ( 1 )
  {
    result = v6--;
    if ( !(_DWORD)result )
      break;
    v4 = v5++;
    *v4 = a2;
  }
  return result;
}

//----- (0000000000000400) ----------------------------------------------------
void __fastcall memcpy(_BYTE *dst, char *src, __int64 a3)
{
  __int64 v3; // rax
  char *v4; // rax
  char v5; // dl
  char *v6; // rax
  char *v7; // [rsp+0h] [rbp-28h]
  char *v8; // [rsp+8h] [rbp-20h]
  __int64 v9; // [rsp+10h] [rbp-18h]

  v9 = a3;
  v8 = dst;
  v7 = src;
  while ( 1 )
  {
    v3 = v9--;
    if ( !v3 )
      break;
    v4 = v7++;
    v5 = *v4;
    v6 = v8++;
    *v6 = v5;
  }
}

//----- (00000000000004F0) ----------------------------------------------------
__int64 __fastcall strlen(char *a1)
{
  unsigned int i; // [rsp+0h] [rbp-Ch]

  for ( i = 0; a1[i]; ++i )
    ;
  return i;
}

//----- (0000000000000530) ----------------------------------------------------
__int64 __fastcall memcmp(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned __int8 *i; // [rsp+0h] [rbp-30h]
  unsigned __int8 *v6; // [rsp+8h] [rbp-28h]
  __int64 v7; // [rsp+10h] [rbp-20h]

  v7 = a3;
  v6 = a1;
  for ( i = a2; ; ++i )
  {
    v3 = v7--;
    if ( !v3 )
      break;
    if ( *v6 != *i )
      return (unsigned int)(*v6 - *i);
    ++v6;
  }
  return 0;
}

//----- (00000000000005C0) ----------------------------------------------------
__int64 __fastcall strcmp(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned __int8 *i; // [rsp+0h] [rbp-10h]
  _BYTE *v4; // [rsp+8h] [rbp-8h]

  v4 = a1;
  for ( i = a2; *v4 && *v4 == *i; ++i )
    ++v4;
  return (unsigned __int8)*v4 - (unsigned int)*i;
}

//----- (0000000000000630) ----------------------------------------------------
__int64 __fastcall strncmp(char *a1, char *a2, __int64 a3)
{
  __int64 v3; // rax
  char *v4; // rax
  int v5; // edx
  char *v6; // rax
  __int64 v8; // [rsp+0h] [rbp-20h]
  char *v9; // [rsp+8h] [rbp-18h]
  char *v10; // [rsp+10h] [rbp-10h]

  v10 = a1;
  v9 = a2;
  v8 = a3;
  while ( 1 )
  {
    v3 = v8--;
    if ( !v3 )
      break;
    v4 = v10++;
    v5 = *v4;
    v6 = v9++;
    if ( v5 != *v6 )
      return (unsigned int)((unsigned __int8)*(v10 - 1) - (unsigned __int8)*(v9 - 1));
  }
  return 0;
}

//----- (0000000000000780) ----------------------------------------------------
__int64 __fastcall put_str(char *a1)
{
  __int64 result; // rax
  unsigned int i; // [rsp+10h] [rbp-10h]
  signed int v3; // [rsp+14h] [rbp-Ch]

  v3 = strlen(a1);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (signed int)i >= v3 )
      break;
    sys_putchar((char *)(unsigned int)a1[i]);
  }
  return result;
}

//----- (00000000000007E0) ----------------------------------------------------
int __fastcall is_upper(char a1)
{
  _BOOL1 v2; // [rsp+1h] [rbp-5h]

  v2 = 0;
  if ( a1 >= 'A' )
    v2 = a1 <= 'Z';
  return v2;
}

//----- (0000000000000810) ----------------------------------------------------
int __fastcall is_lower(signed int a1)
{
  _BOOL1 v2; // [rsp+1h] [rbp-5h]

  v2 = 0;
  if ( a1 >= 'a' )
    v2 = a1 <= 'z';
  return v2;
}

//----- (0000000000000840) ----------------------------------------------------
__int64 __fastcall to_lower(signed int a1)
{
  unsigned int v2; // [rsp+4h] [rbp-4h]

  if ( a1 < 'A' || a1 > 'Z' )
    v2 = a1;
  else
    v2 = a1 + 32;
  return v2;
}

//----- (0000000000000880) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
_BYTE *__fastcall stristr(char *haystack, char *needle)
{
  char *v2; // rsi
  __int64 v3; // rsi
  char v5; // [rsp+Eh] [rbp-22h]
  char v6; // [rsp+Fh] [rbp-21h]
  unsigned int i; // [rsp+10h] [rbp-20h]
  unsigned __int8 v8; // [rsp+16h] [rbp-1Ah]
  unsigned __int8 v9; // [rsp+17h] [rbp-19h]
  char *v10; // [rsp+20h] [rbp-10h]

  v10 = haystack;
  if ( *(_OWORD *)&haystack == 0LL )
    return 0LL;
  v8 = *v2;
  v9 = *v2;
  if ( is_upper(*v2) )
  {
    v9 = to_lower(v9);
  }
  else if ( is_lower(v8) )
  {
    v8 &= 0xDFu;
  }
  if ( !v9 )
    return haystack;
  while ( 1 )
  {
    if ( !*v10 )
      return 0LL;
    if ( v9 == *v10 || v8 == *v10 )
      break;
LABEL_23:
    ++v10;
  }
  for ( i = 1; ; ++i )
  {
    v6 = *(_BYTE *)(v3 + i);
    v5 = v10[i];
    if ( !v6 )
      return v10;
    if ( !v5 )
      break;
    if ( is_upper(v6) )
      v6 = to_lower(v6);
    if ( is_upper(v5) )
      v5 = to_lower(v5);
    if ( v6 != v5 )
      goto LABEL_23;
  }
  return 0LL;
}
// 880: variables would overlap: rdi.8 and di.16

//----- (0000000000000A50) ----------------------------------------------------
__int64 __fastcall prompt(__int64 a1)
{
  return put_str("[RTOoOS> ");
}

//----- (0000000000000A70) ----------------------------------------------------
__int64 __fastcall do_command(char *line, int a2)
{
  __int64 v2; // rax
  unsigned __int16 v3; // dx
  int v4; // eax
  int v5; // eax
  int v6; // ST6C_4
  int v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // ST34_4
  int v11; // eax
  int v12; // ST30_4
  int v13; // eax
  int v14; // edi
  int v15; // eax
  signed int i; // [rsp+ACh] [rbp-74h]
  signed int j; // [rsp+BCh] [rbp-64h]
  signed int ll; // [rsp+C0h] [rbp-60h]
  signed int kk; // [rsp+C4h] [rbp-5Ch]
  int jj; // [rsp+C8h] [rbp-58h]
  signed int ii; // [rsp+CCh] [rbp-54h]
  int v23; // [rsp+D0h] [rbp-50h]
  signed int n; // [rsp+D4h] [rbp-4Ch]
  signed int m; // [rsp+D8h] [rbp-48h]
  int inp_ind; // [rsp+DCh] [rbp-44h]
  int out_ind; // [rsp+E4h] [rbp-3Ch]
  signed int l; // [rsp+E8h] [rbp-38h]
  signed int k; // [rsp+ECh] [rbp-34h]
  char *value; // [rsp+F8h] [rbp-28h]
  char *key; // [rsp+100h] [rbp-20h]
  signed int v32; // [rsp+108h] [rbp-18h]
  int v33; // [rsp+10Ch] [rbp-14h]
  int v34; // [rsp+10Ch] [rbp-14h]
  unsigned int v35; // [rsp+11Ch] [rbp-4h]

  v33 = a2;
  v32 = strlen(line);
  if ( v32 <= 512 )
  {
    if ( line[v32 - 1] == 10 )
      line[v32 - 1] = 0;
    if ( (unsigned int)strcmp("help", (unsigned __int8 *)line) )
    {
      v2 = strcmp("ls", (unsigned __int8 *)line);
      if ( (_DWORD)v2 )
      {
        if ( (unsigned int)strcmp("id", (unsigned __int8 *)line) )
        {
          v4 = strlen("cat ");
          if ( (unsigned int)strncmp("cat ", line, v4) )
          {
            v5 = strlen("export ");
            if ( (unsigned int)strncmp("export ", line, v5) )
            {
              if ( (unsigned int)strcmp("env", (unsigned __int8 *)line) )
              {
                if ( !(unsigned int)strcmp("exit", (unsigned __int8 *)line) )
                  sys_exit();
                v15 = strlen("unset ");
                if ( (unsigned int)strncmp("unset ", line, v15) )
                {
                  sys_write("command not found, press \"help\" for help!");
                }
                else                            // unset
                {
                  for ( i = 0; i < 16; ++i )
                  {
                    if ( (unsigned int)strlen((char *)(((signed __int64)i << 9) + 5712))
                      && !(unsigned int)strcmp((_BYTE *)(((signed __int64)i << 9) + 5712), (unsigned __int8 *)line + 6) )
                    {
                      keys[(signed __int64)i].name[0] = 0;
                      free(values[i]);
                      return 0;
                    }
                  }
                }
              }
              else                              // env
              {
                for ( j = 0; j < 16; ++j )
                {
                  if ( (unsigned int)strlen((char *)(((signed __int64)j << 9) + 0x1650)) )
                  {
                    put_str((char *)(((signed __int64)j << 9) + 0x1650));
                    put_str("=");
                    put_str(values[j]->str);
                    put_str("\n");
                  }
                }
              }
            }
            else                                // export
            {
              key = &line[(signed int)strlen("export ")];
              value = 0LL;
              for ( k = 0; k < (signed int)strlen(key); ++k )
              {
                if ( key[k] == '=' )
                {
                  value = &key[k + 1];
                  key[k] = 0;
                  break;
                }
              }
              for ( l = 0; l < 16; ++l ) {
                out_ind = 0;
                if (!strlen(env_list[ENV_SIZE* l]))
                  // Not allocated
                  continue; 
                if (strcmp(env_list[ENV_SIZE * l], key))
                  continue;

                v6 = v33 - strlen(key);
                readBytes -= strlen(key) + strlen("export");
                inp_ind = 0;
                while (inp_ind < readBytes)
                {
                  if ( value[inp_ind] == '$' ) // Expansion
                  {
                    for ( m = 0; m < 16; ++m )
                    {
                      v7 = strlen(env_list[ENV_SIZE * m]);
                      if (strncmp(value[inp_ind+1], env_list[ENV_SIZE * m], v7))
                        continue;

                      for ( n = 0; n < strlen(values[m]->str); ++n )
                      {
                        values[l][out_ind] = values[m]->str[n];
                        out_ind++;
                      }
                      inp_ind += strlen(values[m]->str);
                      break;
                    }
                  }

                  values[l][out_ind++] = value[inp_ind++];
                }
              }
              v23 = 0;
              for ( ind = 0; ind < 16; ++ind )
              {
                if (strlen(env_list[ENV_SIZE * ind])) 
                  // Occupied
                  continue;

                memcpy(env_list[ENV_SIZE * ind], key, strlen(key));
                values[ind] = malloc(ENV_SIZE - strlen(key) - strlen("export ") + 1)

                v12 = 512 - (unsigned __int64)strlen(key);
                v34 = v12 - (unsigned __int64)strlen("export ");
                /* Same as code above */
                for ( jj = 0; jj < v34; values[ind]->str[v23++] = value[jj++] )
                {
                  if ( value[jj] == 36 )
                  {
                    for ( kk = 0; kk < 16; ++kk )
                    {
                      v13 = strlen((char *)(((signed __int64)kk << 9) + 0x1650));
                      if ( !(unsigned int)strncmp(&value[jj + 1], (char *)(((signed __int64)kk << 9) + 0x1650), v13) )
                      {
                        for ( ll = 0; ll < (signed int)strlen(values[kk]->str); ++ll )
                        {
                          v14 = v23++;
                          values[ind]->str[v14] = values[kk]->str[ll];
                        }
                        jj += strlen(values[kk]->str);
                        break;
                      }
                    }
                  }
                }
                return 0;
              }
            }
          }
          else                                  // cat
          {
            if ( (signed int)strlen(line) <= 4 )
            {
              v35 = 0;
              sys_write("no file to cat");
              return v35;
            }
            if ( stristr(line + 4, "honcho") )
              sys_write("reading hypervisor blocked by kernel!!");
            else
              sys_write_file((__int64)(line + 4));
          }
        }
        else                                    // id
        {
          sys_write("uid=0(root) gid=0(wheel) groups=0(wheel)");
        }
      }
      else
      {
        sys_ls(v2, v3);
      }
    }
    else                                        // help
    {
      sys_write("help text TODO!");
    }
    return 0;
  }
  return (unsigned int)-1;
}

//----- (00000000000013F0) ----------------------------------------------------
int __cdecl __noreturn start()
{
  __int64 v0; // rdx
  __int64 v1; // rcx
  __int64 v2; // rdi
  __int64 v3; // rsi
  int a2; // ST1C_4
  char buff[512]; // [rsp+20h] [rbp-230h]
  __int64 v6; // [rsp+228h] [rbp-28h]
  __int64 v7; // [rsp+230h] [rbp-20h]
  __int64 v8; // [rsp+238h] [rbp-18h]
  __int64 v9; // [rsp+240h] [rbp-10h]

  v9 = v2;
  v8 = v3;
  v7 = v0;
  v6 = v1;
  init_heap((chk *)&unk_3650, 0x1000LL);
  sys_write("CS420 - Homework 1");
  sys_write("Student: Kurt Mandl");
  sys_write("Submission Stardate 37357.84908798814");
  while ( 1 )
  {
    memset(buff, 0, 0x200u);
    prompt((__int64)buff);
    a2 = sys_read_input((__int64)buff, 0x1FFLL);
    do_command(buff, a2);
  }
}

// ALL OK, 25 function(s) have been successfully decompiled
